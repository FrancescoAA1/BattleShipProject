// TO DO 

Implementare lettura comandi XX XX per attivare visualizzazione mappe
Sistemare colonne mappe
Debug Sottomarino
Passaggio a Unique Ptr
Creare eseguibile a parte per il Replay
File ReadMe

==================================================================================

Usare in Game Funzionalità di replay 


se la modalità è replay non viene invocato il metodo di scambio dei riferimenti 
Fare in Game costruttore per il replay 
==================================================================================

// COSE FATTE =======================================================================================
1) scrivere main
2) metodi mancanti: metodo che data una posizione generata casualmente 
ne genera una seconda con x oppyre y uguale (aggiunta nave robot) Metodo get_random_pos1 
in RobotPlayer --> Accetta come parametri una Posizione e un intero (taglia della nave da creare).
(fatto)

aggiungere il distruttore di player --> (fatto)
aggiungere il distruttore di Game --> (fatto)

richiamare operator << per la stampa mappe di attacco e difesa con comando AA AA --> presente in 
player.cpp (Metodo check_for_graphic_cmd, parte commentata) ----> fatto

4) I METODI GETTER NELLE CLASSI CHE HANNO DELLE DERIVATE XXXXX
se una classe ha delle classi derivate, queste potrebbero dover accedere a dei membri privati
per farlo solitamente si penserebbe di usare il getter, ma un normale getter, del genere
ClassType get_field() const {return field;}
ritorna una copia del campo, che è utile solo in lettura ma ovviamente non in scrittura
per modificare effettivamente il campo ci sarebbero i metodi setter, ma se il campo è un oggetto
e non tipo di dato primitivo, il setter non è di aiuto
si potrebbe fare un getter del tipo
ClassType& get_field() {return field;}
ma questo violerebbe l'incapsulamento, in quanto un metodo pubblico permetterebbe di modificare un
membro privato
La soluzione che ho trovato migliore è stata quella di mettere tali membri come protected (restituire una reference non è un errore
di per sè, ma è più corretto fare così secondo me, quindi potremmo sistemarlo alla fine del progetto)
----------> Ottima Soluzione. 

5) Nella creazione delle mosse del computer e la creazione delle coordinate delle navi std::rand si dimostra poco randomico (crea sempre le stesse coordinate)
------> non ci si può far nulla

controllare codice per la rimozione della nave (removeship (uso di find ed erase)) (Metodo
receive_attack in Player.cpp) --> sezione commentata

6) Bug Robot Player: invocazione del metodo receive_attack presente in Player.cpp, lancia Floating Point Exception (core dumped) a riga 36, durante la rimozione della nave


9)Le Coordinate per la corazzata C3 G7 lanciano Segmentation Fault

5) Bug nella rappresentazione (o forse nei metodi della mappa stessa di agigunta navi). Le navi risultano sovrapposte nella defense map.
//Aggiornamento: il sottomarino può essere messo ovunque (non importa se cella è occupata)
//Segmentation Fault per coordinate come V3 V3 (potrebbe essere problema convert_to_position)

7) Segmentation fault lanciato da mosse del tipo D2 D2, cioè con target e origine identiche.

spostare i metodi che vanno in Utility nella apposita raccolta di metodi

4) Action di Submarine.cpp
Non Sempre il vettore di attackUnit ottenuto come parametro ha kSide*kSide unit. Ad esempio, se si effettua la scansione a partire dalla posizione
d'angolo della mappa A1, il vettore avrà 9 celle. Quindi il minimo di unità nel vettore sono parte alta di kSide*parte alta di kSide. Va quindi sistemato il controllo.
Vedi algoritmo presente in test_components

6) Bug nell'attackGrid (o nel passaggio del riferimento alla nave che chiama il to_string). L'attackgrid risulta sempre vuota.

8) Errore inserendo riga vuota come mossa o aggiunta nave (da risolvere in Player.cpp nel prelievo dell'input)


10) Quando l'azione della nave fallisce è necessario che il player se ne accorga e richeda l'inserrimento di un'altra mossa

metodo per scambiare i riferimenti dei player in modo casuale (per decidere chi inizia la partita)
-->da creare nel header player.h e implementare in player.cpp

convertire a unique pointer i puntatori a nave della collezione in player

Bug negli attacchi eccetera 

digitando il
comando BB BB possono essere cancellati tutti i caratteri relativi a colpi andati a segno (X),
oppure con il comando CC CC si possono cancellare tutti i colpi a vuoto (O).

Q14. Nel caso una nave con un segmento già colpito si muova e venga rilevata da un
sonar nella nuova posizione, il segmento colpito, nel campo d'attacco del giocatore che
ha lanciato il sonar, viene visualizzato con una 'X' (facendo capire quindi che la nave
rilevata era quella colpita in precedenza) o viene visualizzato con una 'Y' (come se fosse
una normale rilevazione del sonar)?
A14. In questo caso la nave rilevata dal sonar verrà visualizzata con il segmento colpito. In altre
parole, il sonar ritorna la posizione e lo stato corrente delle nave.

==================================================================================
3) Funzionalità di replay in game


se la modalità è replay non viene invocato il metodo di scambio dei riferimenti 
Fare in Game costruttore per il replay 

inizio i due nomi dei player (2righe)
[per convenzione il primo scritto è quello che parte]
numero massimo di round (opz.)

tutte le mosse 

metodo per prelevare primo giocatore
metodo per prelevare secondo giocatore
metodo numero massimo di round 
hasNext
next
==================================================================================

Implementare file wrapper per fare la scrittura di un replay su file: lo usa la classe game 