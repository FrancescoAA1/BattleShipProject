// TO DO 

metodo per scambiare i riferimenti dei player in modo casuale (per decidere chi inizia la partita)
-->da creare nel header player.h e implementare in player.cpp

convertire a smart pointer i puntatori a nave della collezione in player

spostare i metodi che vanno in Utility nella apposita raccolta di metodi 

3) Funzionalità di replay

Importante!

4) Action di Submarine.cpp
Non Sempre il vettore di attackUnit ottenuto come parametro ha kSide*kSide unit. Ad esempio, se si effettua la scansione a partire dalla posizione
d'angolo della mappa A1, il vettore avrà 9 celle. Quindi il minimo di unità nel vettore sono parte alta di kSide*parte alta di kSide. Va quindi sistemato il controllo.
Vedi algoritmo presente in test_components

6) Bug nell'attackGrid (o nel passaggio del riferimento alla nave che chiama il to_string). L'attackgrid risulta sempre vuota.

8) Errore inserendo riga vuota come mossa o aggiunta nave (da risolvere in Player.cpp nel prelievo dell'input)

10) Quando l'azione della nave fallisce è necessario che il player se ne accorga e richeda l'inserrimento di un'altra mossa



// COSE FATTE ==========================================================================================================
1) scrivere main
2) metodi mancanti: metodo che data una posizione generata casualmente 
ne genera una seconda con x oppyre y uguale (aggiunta nave robot) Metodo get_random_pos1 
in RobotPlayer --> Accetta come parametri una Posizione e un intero (taglia della nave da creare).
(fatto)

aggiungere il distruttore di player --> (fatto)
aggiungere il distruttore di Game --> (fatto)

richiamare operator << per la stampa mappe di attacco e difesa con comando AA AA --> presente in 
player.cpp (Metodo check_for_graphic_cmd, parte commentata) ----> fatto

4) I METODI GETTER NELLE CLASSI CHE HANNO DELLE DERIVATE XXXXX
se una classe ha delle classi derivate, queste potrebbero dover accedere a dei membri privati
per farlo solitamente si penserebbe di usare il getter, ma un normale getter, del genere
ClassType get_field() const {return field;}
ritorna una copia del campo, che è utile solo in lettura ma ovviamente non in scrittura
per modificare effettivamente il campo ci sarebbero i metodi setter, ma se il campo è un oggetto
e non tipo di dato primitivo, il setter non è di aiuto
si potrebbe fare un getter del tipo
ClassType& get_field() {return field;}
ma questo violerebbe l'incapsulamento, in quanto un metodo pubblico permetterebbe di modificare un
membro privato
La soluzione che ho trovato migliore è stata quella di mettere tali membri come protected (restituire una reference non è un errore
di per sè, ma è più corretto fare così secondo me, quindi potremmo sistemarlo alla fine del progetto)
----------> Ottima Soluzione. 

5) Nella creazione delle mosse del computer e la creazione delle coordinate delle navi std::rand si dimostra poco randomico (crea sempre le stesse coordinate)
------> non ci si può far nulla

controllare codice per la rimozione della nave (removeship (uso di find ed erase)) (Metodo
receive_attack in Player.cpp) --> sezione commentata

6) Bug Robot Player: invocazione del metodo receive_attack presente in Player.cpp, lancia Floating Point Exception (core dumped) a riga 36, durante la rimozione della nave


9)Le Coordinate per la corazzata C3 G7 lanciano Segmentation Fault

5) Bug nella rappresentazione (o forse nei metodi della mappa stessa di agigunta navi). Le navi risultano sovrapposte nella defense map.
//Aggiornamento: il sottomarino può essere messo ovunque (non importa se cella è occupata)
//Segmentation Fault per coordinate come V3 V3 (potrebbe essere problema convert_to_position)

7) Segmentation fault lanciato da mosse del tipo D2 D2, cioè con target e origine identiche.